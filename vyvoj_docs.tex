\chapter{Vývojová dokumentace}

%Tato kapitola detailně popisuje implementaci našeho programu. V každé sekci podrobně rozebereme jednu část řešení, rozhodnutí vedoucí k její implementaci a případné problémy, na které jsme narazili během vývoje.
\section{Datové struktury}\label{data}

Základní datovou strukturou v~OpenSMT je \icode{Pterm}, reprezentující jeden term vyskytující se ve vstupní formuli. Odkazy na tyto termy jsou pak předávány pomocí referenční struktury \icode{PTRef}. Ta obsahuje pouze numerický identifikátor použitý k~jejímu rozlišení. Mapování jednotlivých referencí na odpovídající termy přitom zařizuje třída \icode{Logic}, respektive její potomci. \icode{Logic} si ukládá převodní tabulku párující \icode{PTRef} a~jejich odpovídající \icode{Pterm} a~poskytuje také mechanismy pro vytváření nových termů. Její potomci pak rozšiřují tyto mechanismy o~možnosti odpovídající dané teorii, např. s~\icode{LALogic} jsme schopni vytvářet termy odpovídající nerovnicím z~lineární aritmetiky. Jelikož rozdílová omezení jsou speficickým tvarem lineárních nerovnic, využívá náš řešič právě schopností \icode{LALogic}, konkrétně \icode{LIALogic} pro implementovanou celočíselnou verzi.

Ohodnocení proměnných je uloženo ve struktuře \icode{PtAsgn}, která obsahuje \icode{PTRef} odpovídající ohodnocené proměnné a~\icode{lbool} označující její ohodnocení (\icode{lbool} je běžný optional boolean).

Samotné termy mají stromovou strukturu. Pokud se nejedná o~atomickou proměnnou, reprezentuje term nějaký $n$-ární funkční či relační symbol společně s~jeho argumenty. K~rozlišení typu symbolu nám opět poslouží API třídy \icode{Logic}, pro přístup k~argumentům je pak použit operátor \icode{[]}. Reprezentuje-li například \icode{Pterm~p} term $(x \lor y)$, budeme mít přístup k~proměnným \icode{p[0]} a~\icode{p[1]}, což jsou \icode{PTRef} reprezentující $x$, respektive $y$. 

\begin{code}[label=Příklad práce s~termem p $\approx (4 \leq x)$]
PTRef p;    
assert( logic.isNumLeq(p) );
Pterm &term = logic.getPterm(p);

PTRef c = term[0];
assert( logic.isNumConst(c) );
opensmt::Number n = logic.getNumConst(c);
assert( n == 4 );

PTRef x = term[1];
assert( logic.isNumVar(x) );
\end{code}

Nejdůležitější datovou strukturou našeho řešiče je \icode{Edge}. V~té jsou uloženy informace o~jedné hraně omezujícího grafu. Konkrétně tedy obsahuje reference na její vstupní a~výstupní vrchol, ohodnocení, odkaz na svou negaci a~informaci o~tom, kdy byla přidána do omezujícího grafu. Po vzoru frameworku přitom zbytek řešiče nepracuje přímo s~těmito strukturami, ale s~jejich referencemi \icode{EdgeRef}, které opět obsahují pouze jednoznačný numerický identifikátor. Samotné hrany se pak nacházejí jen v~centrálním úložišti, které tvoří třída \icode{STPStore}. Ta zařizuje zejména tvorbu nových hran a~převod z~\icode{EdgeRef} na \icode{Edge\&}. Použit je i~protějšek k~\icode{EdgeRef} pro vrcholy, struktura \icode{VertexRef}. Jelikož se však s~vrcholy nepojí žádná informace, nejedná se o~odkaz na další strukturu, ale pouze o~symbolické reference, sloužící pro vzájemné rozlišení jednotlivých vrcholů.

%\captionof{verbatim}{test}
\begin{code}[label=Deklarace struktury Edge]
struct Edge {
    VertexRef from, to;    
    EdgeRef neg;           
    ptrdiff_t cost;
    uint32_t setTime;
}
\end{code}

Jelikož náš řešič dostává od frameworku informace o~proměnných zásadně jako \icode{PTRef}, potřebujeme způsob, jak přecházet mezi reprezentací frameworku a~interní reprezentací našeho řešiče. K~tomuto účelu slouží třída \icode{STPMapper}. V~této třídě se vyskytuje hned několik druhů převodních tabulek. Pamatuje si převod z~\icode{PTRef} na \icode{VertexRef}, přiřazující proměnné k~vrcholům grafu, a~převod z~\icode{PTRef} na \icode{EdgeRef}, přiřazující nerovnice k~hranám. Tyto převody jsou zásadní pro interpretaci příkazů frameworku. Pro hrany si pamatuje i~opačný převod, mapující \icode{EdgeRef} zpět na odpovídající \icode{PTRef}. Ten je důležitý pro oznámení nalezených dedukcí (viz.~\ref{dusl}). Pro účely oznámení nesplnitelné množiny literálů si pro hrany právě v~grafu pamatujeme i~mapu z~\icode{EdgeRef} na \icode{PtAsgn}, které způsobily jejich přidání do grafu. Uvědomme si, že tento převod není zaměnitelný s~předchozím převodem na \icode{PTRef}, jelikož hrana se může vyskytnout v~grafu z~důvodu záporného ohodnocení její negace. \icode{STPMapper} si navíc pamatuje pro každý vrchol seznam všech hran, ve kterých se daný vrchol vyskytuje, jak je popsáno v~\ref{alg}.

Samotný omezující graf ukládáme do struktury \icode{STPEdgeGraph}. Ta obsahuje seznam přidaných hran a~oboustranný seznam sousedů pro všechny vrcholy grafu. S~grafem přímo manipuluje třída \icode{STPGraphManager}, která působí jako hlavní výpočetní třída řešiče. Provádí přidávání hran do grafu a~jejich případné odebírání z~grafu, ale i~hledání důsledků přidané hrany a~hledání vysvětlení nalezeného důsledku.

Třídu \icode{STPModel} využijeme, pokud chceme pro splnitelnou množinu nerovnic najít nějaké ohodnocení proměnných. \icode{STPModel} dostane kopii grafu, ze které vytvoří mapu ohodnocení obsažených vrcholů.

Všechny struktury řešiče spojuje dohromady hlavní třída \icode{STPSolver}. Jakožto potomek \icode{TSolver} implementuje tato třída rozhranní mezi řešičem a~zbytkem frameworku. %% TODO add more.

\begin{figure}
	\centering
	\includegraphics[width=0.8\textwidth]{class_deps}
	\caption{Závislosti mezi strukturami řešiče}
\end{figure}

Je vhodné zmínit, že za dobu vývoje OpenSMT v~něm vzniklo několik implementací základních datových struktur. Hojně užívaným příkladem je třída \icode{vec}, reprezentující běžný vektor. Vyjma malých rozdílů API a~údajné vyšší efektivity na primitivních typech se tyto třídy výrazně neliší od implementací ze standardní knihovny. Konkrétně třída \icode{vec} je navíc omezena skutečností, že jejími prvky nemohou být typy obsahující odkazy (vyjímkou z~tohoto pravidla je zvlášť implementovaný \icode{vec$\langle$vec$\langle$T$\rangle\rangle$}). Za účelem konzistence se zbytkem frameworku jsme se přesto rozhodli využívat tyto lokální struktury všude, kde je to možné. 
\newpage
\section{Přidávání literálů}\label{add}

Na samotném začátku výpočtu se OpenSMT postupně pro každý term zeptá řešiče, zda se jedná o~literál jeho teorie. Jelikož tento proces slouží primárně k~jejich odlišení běžných booleovských termů, nezkoumáme do hloubky struktury termu, ale provádíme jen povrchovou kontrolu. Pokud předpokládáme, že framework použije náš řešič jen pro odpovídající teorii, je taková kontrola dostačující.
\begin{code}
bool STPSolver::isValid(PTRef tr) { return logic.isNumLeq(tr); }
\end{code}

Jakmile jsou termy takto rozlišeny, řešič je informován o~všech literálech, jejichž ohodnocení mu může být oznámeno. K~tomu je využita funkce \icode{declareAtom(PTRef)}. V~té už musíme projít strukturu literálu, abychom z~něj extrahovali relevantní informace. Důležité pro nás přitom je, že díky způsobu, kterým OpenSMT vytváří své termy, nemusíme provádět konverze z~různých tvarů omezení (popsaných v~sekci \ref{stp}). Neostrých nerovností a~obrácených znamének jsme tak v~literálech zbaveni dříve, než se o~nich řešič vůbec dozví --- všechny literály naší teorie jsou reprezentovány standardní formou $c \leq x - y$, popř. $c \leq \pm x$ pro omezení s~jednou proměnnou.\footnote{Tato kanonická transformace mimo jiné ospravedlňuje výše zmíněnou implementaci \icode{isValid}.} Uveďme pro úplnost, že rozdíl je v~této reprezentaci nahrazen součtem záporu. Přesnější popis struktury literálu tak je spíše $c \leq x + (-1 \cdot y)$.

Z~této formy nám už nedělá problém určit hodnotu $c$ a~reference na $x$ a~$y$ postupem naznačeným v~předchozí sekci. Musíme přitom dbát pouze na to, že nerovnice je v~opačné formě než té námi používané. Hrany omezujícího grafu tudíž povedou z~$y$ do $x$ s~ohodnocením $-c$. Tuto odlišnost zdůrazňujeme, protože je v~implementaci práce použití identifikátorů \icode{x} a~\icode{y} standardizováno ve smyslu cílového, resp. zdrojového vrcholu hrany.

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{ptref_structure}
	\caption{Ukázka struktury termu (\icode{PTRef tr} $\approx c \leq x - y$)}
\end{figure}

Jakmile jsme získali informace o~hraně, musíme nejprve zkontrolovat, zda už hrana v~našem řešiči neexistuje. To se může stát, pokud je hrana negací jiné již přidané hrany (viz. níže). %% TODO garbage reference
Hledání hrany probíhá postupným projitím seznamu všech hran, ve kterých se vyskytuje $y$ (seznamy si pro každý vrchol ukládá \icode{STPMapper}). Probíhá tedy lineárně v~počtu hran obsahujících $y$. Jelikož ale přidávání literálů celkově zabírá jen minimální část celého výpočtu, usoudili jsme, že lineární složitost této operace je pro nás přijatelným kompromisem.

Objevíme-li hranu odpovídající přidanému literálu, stačí nám přidat do třídy \icode{STPMapper} tuto asociaci. Všechny ostatní informace o~hraně už známe. V~opačném případě musí ze všeho nejdříve \icode{STPStore} tuto hranu vytvořit (případně s~vrcholy, které jsme ještě nepotkali). Jakmile je hrana vytvořená, vytvoříme předběžně i~její negaci (z~důvodů popsaných v~sekci \ref{upravy}). Obě nově vytvořené hrany pak přidáme do seznamů hran pro jejich vrcholy. U~původní hrany si navíc uložíme její asociaci s~oznámeným literálem (pro negaci zatím tato asociace neexistuje). 

Poté, co tento proces proběhne pro všechny literály ve vstupní formuli, jsme schopni každý literál převézt na odpovídající hranu a~naopak a~dokážeme reprezentovat libovolné ohodnocení přidáním odpovídající hrany do omezujícího grafu.

\section{Oznámení ohodnocení a~hledání důsledků}\label{dusl}

Nejdůležitější část výpočtu se odehrává ve funkci \icode{STPSolver::assertLit}, pomocí které se řešič dozvídá o~nových ohodnocení literálů. Funkce nejprve převede literál na odpovídající hranu. Následně zkontroluje, zda jsme hranu již neobjevili. Je-li hrana označená jako \emph{pravdivá} (tj. je buď v~omezujícím grafu, nebo v~seznamu důsledků), můžeme proces ukončit a~oznámit úspěšné přidání ohodnocení. Je-li naopak pravdivě označená negace hrany, přidané ohodnocení je sporné. V~takovém případě si zapamatujeme bod, ve kterém jsme se do sporu dostali, a~skončíme proces oznámením o~neúspěchu přidání hrany. 

Pokud nenastane ani jedna z~těchto možností, uložíme si asociaci hrany s~danou proměnnou \icode{PtAsgn}, přidáme ji do omezujícího grafu a~začneme hledat důsledky tohoto přidání. Přidání hrany do omezujícího grafu znamená její přidání do seznamu hran grafu a~do obou seznamů sousedů a~nastavení její vlastnosti \icode{setTime} na počet aktuálně přidaných hran. Kontrolu pravdivosti hrany z~předchozího odstavce provádíme pomocí vlastnosti \icode{setTime}, která je pro pravdivé hrany nenulová.

Hledání důsledků zařizuje funkce \icode{STPGraphManager::findConsequences}. Ta nejprve najde seznam možných počátečních a~koncových vrcholů pro cesty procházející přidanou hranou. K~tomu využíváme prohledávání do hloubky, jak bylo popsané v~referenčním algoritmu. Prohledávání přitom probíhá sekvenčně --- nejprve hledáme počáteční vrcholy, poté hledáme vrcholy cílové. Jelikož prohledávání na společných datech provádí pouze čtecí operace, bylo by možné tento proces paralelizovat a~hledat obě množiny současně. Během vývoje jsme zkoušeli uplatnit tento přístup, nicméně režie vytváření a~rušení vláken  se ukázala časově náročnější než samotné prohledávání. Prozkoumali jsme také možnost nastavit hranici na velikost grafu určující, zda výpočet proběhne sekvenčně, či paralelně. V~praxi se ale ukázalo, že hranice byla buď příliš vysoká a~vícevláknový přístup nebyl nikdy použit, nebo byla příliš nízká a~použití vláken stále zhoršovalo výkonnost programu. Rozhodli jsme se tak zůstat u~běžné jednovláknové varianty. Využití perzistentního pole vláken nebo rigoróznější hledání limitu pro použití vlákna jsou možné oblasti dalšího zkoumání, dle našeho úsudku by ale nepřinesly podstatné zrychlení algoritmu.

Poté, co obě množiny nalezneme, vybereme tu, jejíž vrcholy se celkově objevují v~menším množství hran (tyto součty počítáme v~průběhu DFS). Pro kažý vrchol z~vybrané množiny projdeme seznam všech hran, v~nichž se vyskytuje (tyto seznamy si ukládá \icode{STPMapper}) a~uložíme si všechny, které jsou důsledky naposledy přidané hrany. Aby byla hrana $a \xrightarrow{c'} b$ důsledkem právě přidané hrany $y \xrightarrow{c} x$, musí platit 
\begin{enumerate}
	\item Existuje cesta $a \rightarrow y \xrightarrow{c} x \rightarrow b$.
	\item $c'$ je větší než délka nekratší takové cesty.
\end{enumerate}

Snadno nahlédneme, že tyto dvě podmínky pokrývají právě všechna omezení, která jsou důsledky přidání hrany $y \xrightarrow{c} x$ do grafu. Jakmile objevíme všechny takovéto hrany, musíme je převézt zpět do tvaru \icode{PtAsgn} a~předat je frameworku. Odpovídá-li přitom hraně \icode{h} literál \icode{tr} a~negaci \icode{h} literál \icode{nr}, objevení \icode{h} jakožto důsledku způsobí označení \icode{PtAsgn(tr,true)} a~\icode{PtAsgn(nr,false)} jako důsledků oznámeného ohodnocení (pokud \icode{tr} a~\icode{nr} existuje). Pokud existuje odpovídající literál \icode{nr} i~k~negaci hrany právě přidané do grafu, nesmíme zapomenout ani na vytvoření důsledku \icode{PtAsgn(nr,false)} pro tuto hranu.

Oznamování takto nalezených dedukcí provádíme pomocí rozhranní abstraktní třídy \icode{TSolver}, jíž je \icode{STPSolver} potomkem. Ta poskytuje funkci \icode{storeDeduction}, které můžeme předat námi vytvořené důsledky. Funkce technicky vzato bere jako parametr strukturu \icode{PtAsgn\_reason}, jež ale v~řešiči existuje pouze z~historických důvodů a~funkčně se nijak neliší od běžného \icode{PtAsgn}. Voláním \icode{storeDeduction} uložíme nalezené důsledky ve vnitřní struktuře \icode{TSolver}, z~níž už je zbytek řešiče dokáže získat.
\section{Rozhodování o~splnitelnosti}\label{rozhod}



\section{Hledání konfliktů a~backtracking}

\section{Nalezení splňujícího ohodnocení}
