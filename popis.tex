\chapter{Popis řešení}

V~této kapitole rozebereme obecné vlastnosti našeho řešení. Nejprve opodstatníme některá koncepční rozhodnutí, která jsme učinili jako důsledek použitého frameworku. Poté si přiblížíme použité datové struktury, nastíníme obecný způsob fungování programu a~zamyslíme se nad rozdíly mezi různými variantami řešeného problému.

\section{Úpravy referenčního algoritmu}\label{upravy}

Naše implementace je převážně založená na algoritmu tak, jak ho postulovali Nieuwenhuis a~Oliveras \cite{Nieuwenhuis05}. Přesto se liší v~některých implementačních detailech, daných zejména odlišnostmi OpenSMT od referenčního DPLL($T$) frameworku. %% TODO finish

Prvním důležitým rozdílem je způsob abstrakce literálů teorie. V~OpenSMT neexistuje způsob, kterým bychom mohli informovat hlavní engine o~vztazích mezi různými nerovnicemi. Obsahuje-li například vstupní formule nerovnice $(x-y\leq 3)$ a~$(y-x<-3)$, algoritmus popsaný v~\cite{Nieuwenhuis05} je pro DPLL($X$) abstrahuje do booleovských symbolů $p$ a~$\neg p$. Této abstrakce nejsme pomocí rozhranní v~OpenSMT schopni. Náš řešič si tedy musí tyto vztahy udržovat interně. 

S~tímto omezením úzce souvisí druhý zásadní rozdíl. Můžeme si všimnout, že schéma uvedené v~sekci \ref{smt} umožňuje frameworku ohodnotit literál pouze jako \emph{true}. Uvědomme si, že to obecně není nijak omezující. Ohodnocení termu $p$ jako \emph{false} totiž můžeme snadno zařídit voláním \icode{SetTrue($\neg p$)}. Protože však OpenSMT nezná tato mapování mezi termy a~jejich negacemi, není pro nás tento přístup validní. Namísto toho využíváme přímočařejší implementace, kde termům můžeme přiřadit ohodnocení \emph{true} i~\emph{false}. Tato odlišnost vyžaduje několik modifikací našeho řešiče. 

Předně musíme být schopni detekovat, zda jedna nerovnice neodpovídá negaci druhé, jak už jsme uvedli výše. Jakmile jsme toho schopni, můžeme záporné ohodnocení hrany implementovat jako přidání negace této hrany do omezujícího grafu. Jak ale postupovat, pokud jsme u~některé hrany tuto negaci nenašli? Naivní přístup by byl vytvořit negaci takové hrany ve chvíli, kdy se objeví její záporné ohodnocení. Takové řešení však není možné. Uvažujme neohodnocenou hranu $h$, která ve vstupní formuli nemá svou negaci. Mějme v~omezujícím grafu nějakou množinu hran $M$ takovou, že $M \cup \{h\}$ tvoří záporný cyklus. Pokud $M$ existuje, očividně je $\neg h$ důsledkem tohoto grafu. Jelikož se ale $\neg h$ nevyskytuje ve vstupní formuli a~$h$ nebyla nikdy záporně ohodnocená, nevyskytuje se $\neg h$ v~seznamu možných hran našeho řešiče. Algoritmus hledání důsledků ji tudíž nemůže nalézt. Kladným ohodnocením $h$ potom vytvoříme záporný cyklus v~omezujícím grafu, čímž porušíme invariant našeho algoritmu a~nekonečně zacyklíme příští hledání důsledků.

Jak vidíme, negace všech hran musí být známy předtím, než proběhne prohledávání grafu. Tento problém jsme se tedy rozhodli vyřešit už při oznamování možných literálů. Když je řešiči předán literál vyskytující se ve formuli, vytvoříme nejen hranu odpovídající tomuto literálu, ale okamžitě i~hranu odpovídající její negaci. Při předávání dalších literálů je pak jen třeba ověřit, zda neodpovídají některé již vytvořené hraně. Podrobněji tento postup popisujeme v~sekci \ref{add}.

Posledním větším rozdílem je způsob zpracování konfliktů. Jedním z~důsledků vyčerpávající propagace je fakt, že řešič nemusí kontrolovat nesplnitelnost předaného ohodnocení. Zapříčinilo-li by přidání nějaké hrany spor, negace této hrany je důsledkem omezujícího grafu. Můžeme přitom předpokládat, že DPLL($X$) negaci objeveného důsledku nikdy řešiči nepředá. OpenSMT se v~tomto ohledu liší ve způsobu, jakým analyzuje sporný stav. Jeho řešiče obecně nepodporují operaci \icode{Explain}, vracející pro nějaký důsledek množinu jeho příčin. Místo toho implementují funkci \icode{getConflict}, která hledá nesplnitelnou množinu literálů. Pro použití této funkce, nutné k~určení úrovně backtrackingu, se ale nejdřív musí řešič dostat do nekonzistentního stavu.

Tyto dva přístupy jsou naštěstí ekvivalentní. Když OpenSMT objeví spor, předá řešiči nějaké zaručeně sporné ohodnocení, čímž ho dostane do nekonzistentního stavu. Z~tohoto důvodu musíme před každým přidáním hrany kontrolovat, zda není sporná se stávajícím ohodnocením (více viz.~\ref{add}). Náš řešič si zapamatuje hranu $h$ odpovídající tomuto ohodnocení a~funkce \icode{getConflict} pak odpovídá volání \icode{Explain($\neg h$)}. 

\section{Popis běhu programu}

V~první fázi algoritmu jsou řešiči předány všechny literály teorie, které se vyskytují ve vstupní formuli. Řešič z~nich nejprve extrahuje relevantní hodnoty. Následně zkontroluje, zda se nejedná o~negaci některého z~již zapamatovaných literálů. Pokud ano, pouze tuto negaci explicitně označí. V~opačném případě vytvoří hranu odpovídající tomuto literálu a~zároveň a~priori hranu tvořící negaci tohoto literálu, jak je popsáno v~sekci \ref{upravy}. Obě nové hrany se stanou součástí úložiště a~jsou zařazeny do překladových tabulek. Zbytek výpočtu pak již může předpokládat, že pracujeme pouze se známými literály, pro něž máme vytvořené hrany.

Poté, co jsou všechna omezení načtena, nastává hlavní část programu. Během té postupně řešič dostává rozhodnutá ohodnocení literálů. Když nějaké obdrží, přidá do omezujícího grafu hranu odpovídající tomuto ohodnocení. Následně proběhne prohledávání objevující všechny důsledky tohoto ohodnocení. Tyto důsledky jsou přeloženy zpět do formy \icode{PtAsgn} a~oznámeny frameworku.

Po nějaké sekvenci těchto ohodnocení buď nalezneme splňující ohodnocení celé formule, nebo se dostaneme do sporu. Spor můžeme rozpoznat tak, že se chystáme přidat do grafu hranu, jejíž negace byla buď dříve do grafu přidána, nebo byla nalezena jako důsledek dřívějšího ohodnocení. V~takovém případě řešič oznámí selhání tohoto ohodnocení a~přejde do chybového stavu. Jakmile je řešič v~chybovém stavu, automaticky zamítá všechna nová ohodnocení. V~této situaci následuje nalezení nesplnitelné množiny. Pokud byla objevená negace hrany explicitně přidána do grafu, je tato množina triviální. Jinak ji získáme modifikovanou verzí prohledání grafu (viz.~\ref{alg}). Jakmile je nesplnitelná množina nalezena a~předána frameworku, rozhodne se podle ní úroveň backtrackingu. Ten je v~OpenSMT řešen obecně pomocí systému záchytných bodů. Řešič může být v~libovolnou chvíli požádán, aby uložil svůj aktuální stav na zásobník. V~případě nutnosti je mu pak sděleno, aby odebral několik bodů z~vrchu tohoto zásobníku a~tím se vrátil do dřívějšího stavu. 

Jakmile se řešič vrátí do konzistentního stavu, tento proces se opakuje, dokud není nalezeno nějaké splnitelné ohodnocení, nebo dokud framework nevyčerpá všechny možnosti ohodnocení. Splnitelnost formule je určena tím, který z~těchto dvou případů nastane. V~případě, že je formule splnitelná, může být řešič na závěr výpočtu ještě požádán, aby vytvořil její model, tzn.~nalezl konzistentní hodnoty pro všechny proměnné obsažené v~literálech teorie.

\section{Srovnání reálné a~celočíselné verze} \label{int_v_real}

Algoritmus uvedený v~sekci \ref{alg} je s~drobnými úpravami použitelný jak pro RDL, tak pro IDL. Přestože v~této práci implementujeme pouze celočíselnou verzi problému, přišlo nám názorné zamyslet se nad rozdíly mezi oběma variantami.

Uveďme nejprve pro zajímavost, že pokud na vstupu podporujeme i~rovnice a~jejich negace, ověření konzistence je možné v~reálných číslech provést polynomiálně, zatímco pro celožíselný obor je ověření NP-těžké --- jsme schopni na něj převést např. problém $k$-barevnosti grafu \cite{slides}.

Prvním zjevným rozdílem pro potřeby naší implementace je reprezentace čísel. Reálná čísla je potřeba reprezentovat jinak, než čísla celá. OpenSMT definuje vlastní datový typ pro reálná čísla nazvaný \icode{FastRational}. V~různých částech kódu jej můžeme najít také pod aliasy \icode{Real} nebo \icode{Number}. Tento typ má několik výhod oproti běžným primitivním typům s~posuvnou desetinnou čárkou. Především se jedná o~typ s~teoreticky neomezenou velikostí. Jelikož využívá struktur větších než jedno procesorové slovo, není limitován kapacitami procesoru. Důsledkem toho je to také typ s~libovolnou přesností. Netrpí tak zaokrouhlovacími chybami a~ztrátou platných číslic u~velkých hodnot jako např. \icode{float} a~\icode{double}.

Samozřejmě bychom mohli \icode{FastRational} použít i~v~celočíselném řešení. Usnadnilo by nám to návrh datových struktur a~umožnilo větší znovupoužitelnost kódu. Testováním se však ukázalo, že aritmetické operace na \icode{FastRational} jsou citelně pomalejší než u~primitivních typů. Náš projekt tak používá primitivní celočíselný typ, konkrétně typ \icode{ptrdiff\_t}. Ten bohužel podporuje pouze hodnoty omezeného rozsahu. Protože ale v~OpenSMT zatím neexistuje ekvivalent \icode{FastRational} pro celá čísla, uznali jsme jej jako nejlepší volbu. Omezení rozsahu se navíc experimentálně ukázalo jako zanedbatelné pro běžné použití --- z~834(?) %TODO find out
testů knihovny SMT-LIB náš řešič vrátil ve všech případech správný výsledek.

Zásadní algoritmický rozdíl je také v~tvorbě negací. Máme-li například na vstupu nerovnici $(x-y<k)$, v~IDL ji triviálně převedeme do tvaru $(x-y\leq k-1)$. V~RDL se ovšem ostrých nerovností tak snadno nezbavíme. Nieuwenhuis a~Olivieras \cite{Nieuwenhuis05} navrhují pro tento případ postup, který postuloval Schrijver \cite{Schrijver86}. Ten je založen na zápisu nerovnosti jako $(x-y\leq k-\delta)$ pro nějaké dostatečně malé $\delta$, které bude záviset pouze na ostatních přítomných nerovnicích. Hodnotu $\delta$ přitom nepočítáme přímo, ale ukládáme si ji pouze symbolicky. (Tohle vysvětlení bude úplnější, až pořádně pochopím jak to funguje) %TODO
V~kontextu OpenSMT už je tento přístup použit v~řešiči teorie lineární aritmetiky.

Na závěr ještě připomeňme omezení týkající se datových struktur použitých v~OpenSMT. Jelikož \icode{FastRational} obsahuje ukazatele, nelze jej --- ani typy, které ho obsahují --- použít například jako prvek třídy \icode{vec}. Na tato omezení je třeba dbát při přechodu z~celočíselné verze na reálnou.

